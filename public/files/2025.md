# 1 京东零售 20250326 一面

1. 登录之后，url 访问无权限页面，如何处理？

   - api 请求权限，api 返回之前，处于 loading 状态
   - api 返回之后，跳转到 404 页面

2. 随机打乱数组元素？

3. 怎么提高渲染效率？

4. 大量运算，js 卡 ui，怎么处理？

5. HTTP 2.0 特性？

6. http 301 302？

7. 指导新人，规范风格统一？

   - 插件同步：工作区 extensions.json 配置

8. 我的压缩算法实现原理

9. npm、pnpm、yarn 区别？

10. css 居中？

11. css 动画实现 loading 效果？

# 2 贝壳找房 20250331 一面

1. 性能优化

   - 加载性能

     - FCP（First Contentful Paint）：首个内容绘制时间，页面首次有内容渲染的时间
     - LCP（Largest Contentful Paint）：最大内容绘制时间，页面中最大可视内容渲染完成的时间，理想值 < 2.5 秒
     - TTFB（Time to First Byte）：首字节到达时间，衡量服务端响应速度
     - FP（First Paint）：首次绘制时间，浏览器开始绘制像素的时间

   - 交互性能

     - FID（First Input Delay）：首次输入延迟，衡量用户首次交互的响应时间，理想值 < 100 毫秒
     - INP（Interaction to Next Paint）：交互到下一次绘制的延迟，衡量用户操作后的响应速度

   - 页面稳定性

     - CLS（Cumulative Layout Shift）：累积布局偏移量，衡量视觉稳定性，理想值 < 0.1

   - 网络性能

     - DNS Lookup Time：DNS 解析时间
     - TCP Connect Time：TCP 连接时间
     - TLS Handshake Time：TLS 握手时间
     - Resource Load Time：资源加载时间

   - 渲染性能
     - FPS（Frames Per Second）：每秒帧数，理想保持在 60 FPS
     - Layout Time：页面布局计算时间
     - Paint Time：页面绘制时间
     - Compositing Time：合成层的时间

2. createPortal

- ReactDOM.createPortal 用于将子组件渲染到指定的 DOM 节点之外。
- 作用：常用于模态框、弹窗等需要在父组件之外渲染的场景。

```jsx
import React from "react";
import ReactDOM from "react-dom";

function Modal({ children }) {
  return ReactDOM.createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("modal-root")
  );
}
```

3. 写一个 new Layout("小明").eat("水果").sleep(5).eat("水") 类或者函数，能够链式调用。

```js
class Layout {
  constructor(name) {
    this.name = name;
    this.queue = [];
    console.log(`${this.name} 创建了 Layout`);
    setTimeout(() => this.runQueue(), 0);
  }

  eat(food) {
    this.queue.push(() => console.log(`${this.name} 正在吃 ${food}`));
    return this;
  }

  sleep(seconds) {
    this.queue.push(() => {
      console.log(`${this.name} 开始睡觉 ${seconds} 秒`);
      const start = Date.now();
      while (Date.now() - start < seconds * 1000) {}
      console.log(`${this.name} 睡醒了`);
    });
    return this;
  }

  runQueue() {
    if (this.queue.length > 0) {
      const task = this.queue.shift();
      task();
      setTimeout(() => this.runQueue(), 0);
    }
  }
}

// 使用示例
new Layout("小明").eat("水果").sleep(5).eat("水");
```

4. 写一个 Promise.all

```js
function PromiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = [];
    let completedCount = 0; // 记录已完成的 Promise 数量
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          completedCount++;
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch((reason) => {
          reject(reason); // 只要有一个 Promise 失败，直接 reject
        });
    });
  });
}
```

# 3 学堂在线 20250415 笔试、一面、二面

1、js 数组有哪些方法；
2、编程：实现任意角度的扇形；
3、编程：实现简单的发布订阅模式；
4、编程：实现简单的 promise；
5、编程：实现一个过滤框，下方展示过滤后的列表；
6、proxy 理解；
7、vue 按钮权限控制；
8、http 常见状态码、请求方法、含义；
9、浏览器缓存；

# 4 元保集团 20250421 一面

# 5 京东 20250421 一面

# 6 百度 20250421 一面

# 7 美团 20250421 一面

# 8 并集科技 20250423 一面

# 9 元保集团 20250425 二面

# 10 百度无人车 20250428 一面

# 11 百度无人车 20250429 二面

# 12 百度无人车 20250507 三面

# 13 百度无人车 20250508 四面

# 14 百度在线 20250610 一面

# 15 百度在线 20250616 二面

# 16 快手 20250619 一面

# 17 百度在线 20250624 三面

# 18 百度文库 20250627 一面

# 19 百度文库 20250701 二面

# 20 顺丰 20250715 一面

# 21 百度在线 20250724 一面

# 22 美团旅居 20250731 一面

**预测的题目**

1、请解释闭包的原理及实际应用场景，结合你的项目举例说明（比如组件封装或工具函数中是否用到）
闭包是指函数及其捆绑的周边状态（词法环境）的引用的组合，其核心原理是函数在定义时可以访问外层函数的变量，且当外层函数执行完毕后，内层函数仍能访问这些变量。  
实际应用场景包括：封装私有变量、实现模块化工具函数等。在开发`jsonstring-pack`工具时，我利用闭包封装了 JSON 压缩的核心逻辑，将递归处理多层嵌套结构的方法与临时缓存变量（如压缩映射表）绑定，避免了全局变量污染，同时保证了压缩过程中数据处理的连续性。

2、手写 Promise.allSettled 实现，需要处理异步任务的所有结果（成功 / 失败）

```javascript
Promise.myAllSettled = function (promises) {
  return new Promise((resolve) => {
    if (!Array.isArray(promises)) {
      return resolve([
        { status: "rejected", reason: new TypeError("参数必须是数组") },
      ]);
    }
    const result = [];
    let count = 0;
    promises.forEach((p, index) => {
      Promise.resolve(p).then(
        (value) => {
          result[index] = { status: "fulfilled", value };
          count++;
          if (count === promises.length) resolve(result);
        },
        (reason) => {
          result[index] = { status: "rejected", reason };
          count++;
          if (count === promises.length) resolve(result);
        }
      );
    });
  });
};
```

3、如何实现一个带并发限制的异步调度器？例如限制同时运行的 Promise 数量为 3

```js
class Scheduler {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  add(promiseCreator) {
    return new Promise((resolve) => {
      this.queue.push({ promiseCreator, resolve });
      this.run();
    });
  }

  run() {
    if (this.running >= this.limit || this.queue.length === 0) return;
    this.running++;
    const { promiseCreator, resolve } = this.queue.shift();
    promiseCreator()
      .then((result) => {
        resolve(result);
        this.running--;
        this.run();
      })
      .catch((err) => {
        resolve(err); // 捕获错误，保证调度继续
        this.running--;
        this.run();
      });
  }
}
```

4、解释原型链与继承，手写一个基于 class 的继承案例（结合你用 React 函数组件的经验，对比 class 组件的继承逻辑）。
原型链是 JavaScript 中实现继承的基础，每个对象都有\_\_proto\_\_属性指向其原型对象，原型对象的\_\_proto\_\_又指向更上层原型，最终指向 null，形成链式结构。

基于 class 的继承案例：

```js
// 父类：基础组件
class BaseComponent {
  constructor(name) {
    this.name = name;
  }
  logName() {
    console.log(`Component name: ${this.name}`);
  }
}

// 子类：表单组件（继承基础组件）
class FormComponent extends BaseComponent {
  constructor(name, fields) {
    super(name);
    this.fields = fields;
  }
  renderFields() {
    console.log(`Rendering fields: ${this.fields.join(",")}`);
  }
}

// React场景对比：类组件依赖继承，函数组件通过组合（Hooks）复用逻辑
// 类组件可能通过extends React.Component实现继承，而函数组件用useState等Hooks拆分逻辑，更灵活
```

5、手写数组去重（考虑对象、NaN 等特殊情况），并优化时间复杂度。

```js
function uniqueArray(arr) {
  const map = new Map();
  return arr.filter((item) => {
    // 处理NaN（Map中NaN视为相等）
    if (Number.isNaN(item)) {
      if (!map.has("NaN")) {
        map.set("NaN", true);
        return true;
      }
      return false;
    }
    // 处理对象（基于引用）
    if (typeof item === "object" && item !== null) {
      const key = JSON.stringify(item); // 简单对象可用，复杂对象需优化
      if (!map.has(key)) {
        map.set(key, true);
        return true;
      }
      return false;
    }
    // 基本类型
    if (!map.has(item)) {
      map.set(item, true);
      return true;
    }
    return false;
  });
}
// 时间复杂度O(n)，空间复杂度O(n)，通过Map实现一次遍历去重
```

6、实现一个 LRU 缓存机制（结合你 “大型表格缓存字段数据” 的经验）。

结合大型表格缓存字段数据的经验，LRU（最近最少使用）缓存核心是淘汰最久未使用的数据：

```js
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map(); // 利用Map的插入顺序特性
  }

  get(key) {
    if (!this.cache.has(key)) return -1;
    const value = this.cache.get(key);
    // 访问后移到最新位置
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key); // 已存在则先删除
    } else if (this.cache.size >= this.capacity) {
      // 超过容量，删除最旧的（Map的第一个元素）
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(key, value); // 插入新值（最新位置）
  }
}
// 在菱电TBOX车联网平台的大型表格中，类似逻辑用于缓存高频访问的字段数据，减少重复渲染计算
```

7、如何检测并修复前端代码中的内存泄漏？举例说明你遇到过的场景（比如 Electron 跨端项目中是否有类似问题）。

内存泄漏常见场景：未清理的事件监听、闭包中引用的 DOM 未释放、定时器未清除等。
在 Electron 项目中，曾遇到过 ipc 通信的回调函数未正确解绑导致的泄漏：当窗口关闭后，ipcRenderer.on 注册的监听仍被引用，导致窗口实例无法被 GC 回收。
解决方式：在组件卸载或窗口关闭时，通过 ipcRenderer.removeListener 手动移除监听；对长期存在的 websocket 连接，在断开时清除所有回调函数，避免引用残留。

8、解释 React 的虚拟 DOM 与 Diff 算法原理，你在 “10 + 万行大型表格” 中是如何通过虚拟滚动优化性能的？具体实现逻辑是什么？

虚拟 DOM：是 React 对真实 DOM 的内存映射，通过 JS 对象描述 DOM 结构，避免频繁操作真实 DOM 的性能开销。
Diff 算法：React 采用分层比较（同层节点对比）、列表节点用 key 标识避免全量对比，降低复杂度。
在 10 + 万行大型表格优化中，虚拟滚动的实现逻辑：
计算可视区域高度与每行高度，确定可视范围内的行索引（如滚动到第 500 行，可视区显示 500-600 行）；
只渲染可视区的行 DOM，非可视区用空白 div 占位（撑开滚动高度）；
监听滚动事件，动态更新可视区行索引并重新渲染对应行，同时复用已创建的 DOM 节点减少创建开销；
结合字段数据缓存，避免重复计算单元格内容，进一步减少渲染压力。

9、Hooks 的设计原理是什么？为什么函数组件比类组件更适合配合 Hooks 使用？你在 “前端开发规范设计” 中迁移类组件到函数组件时遇到过哪些坑？

Hooks 设计原理：基于闭包和链表存储状态，将组件状态与副作用从组件生命周期中抽离，实现逻辑复用。每次渲染时，Hooks 按调用顺序关联对应的状态，因此要求 Hooks 不能在条件语句中调用。
函数组件更适合 Hooks：函数组件本质是纯函数，没有 this 指向问题，Hooks 的状态管理逻辑（如 useState）与函数组件的调用上下文天然契合；而类组件依赖 this.state 和生命周期方法，逻辑分散且复用困难。
迁移类组件到函数组件时的坑：
this 指向丢失：类组件中 this.handleClick = this.handleClick.bind(this)的逻辑需改为箭头函数或直接在 Hooks 中定义；
生命周期映射问题：componentDidMount 与 componentDidUpdate 合并为 useEffect，需注意依赖数组的设置，避免无限循环；
状态更新逻辑：类组件的 setState 是合并更新，而 useState 的更新函数是替换，需手动处理对象类型状态的合并。

10、如何设计一个可复用的表单组件（结合你 “配置型表单组件” 的经验），需要考虑哪些扩展性和性能问题？

结合 WFUZZ 项目的配置型表单组件经验，设计思路：
基于 JSON Schema 驱动：通过转换工具读取 JSON 配置（包含字段类型、校验规则、UI 属性等），自动生成表单项；
组件分层设计：拆分为 Form（容器）、FormItem（单项包装）、FormControl（输入控件，如 Input/Select），通过 Context 传递表单状态；
扩展性考虑：支持自定义控件注册（如特殊日期选择器）、动态增减表单项、嵌套表单（通过递归解析 JSON）；
性能优化：使用 useMemo 缓存生成的表单项配置，useCallback 缓存 onChange 回调，避免因父组件重渲染导致的不必要更新。

11、在跨端项目（如你的 Electron 应用）中，如何处理前端与后端 / 其他端的状态同步？你用 “预定义对象结构 + websocket 更新” 的方案相比传统状态管理（如 Redux）有什么优势？

在 Electron 项目中，前端与 rust 工具端的状态同步方案：
预定义双方一致的数据结构（如{ id: string, status: string, config: object }）；
通过 websocket 实时发送状态更新操作（如{ type: 'update', path: 'status', value: 'running' }）；
前端维护本地状态对象，接收更新操作后通过路径（如 status）定位并修改对应字段，保证两端状态一致。
相比 Redux 的优势：
轻量性：无需引入复杂的 action/reducer 机制，适合跨端间的简单状态同步；
实时性：基于 websocket 的推送模式，比 Redux 的单向数据流更高效；
针对性：为跨端场景设计，避免 Redux 中全局状态树可能导致的冗余。

12、解释 React Context 的使用场景及性能瓶颈，你在项目中是否用过？如果用，如何避免不必要的重渲染？

使用场景：适合全局共享少量稳定数据（如主题配置、用户信息），避免 props 多层传递（“props drilling”）。
性能瓶颈：当 Context 的值变化时，所有消费该 Context 的组件都会重渲染，即染，即使只用到 Context 中的部分数据。
项目中未直接使用 Context，主要因大型表格和跨端项目对性能敏感，更倾向于通过组件组合或状态管理库（如局部状态 + 自定义 hooks）拆分状态，减少不必要的重渲染。若使用 Context，会通过 “拆分多个 Context”（如将主题和用户信息分为两个 Context）、结合 useMemo 缓存 Context 值等方式优化。

13、详细说明你在 “协议模糊测试系统” 中是如何优化 Webpack 配置的？多线程处理具体用了哪些 loader 或插件？构建速度提升了多少？

优化措施：
简化 loader 设置：仅对必要文件（如 jsx、ts）启用 babel-loader，排除 node_modules 目录；
多线程并行处理：使用 thread-loader 配合 babel-loader，将 JS 编译任务分配到多线程执行，配置如下：

```js
module: {
  rules: [
    {
      test: /\.jsx?$/,
      use: [
        "thread-loader", // 多线程处理
        "babel-loader",
      ],
      exclude: /node_modules/,
    },
  ];
}
```

其他优化：启用 cache-loader 缓存编译结果，分离 runtimeChunk 避免哈希值频繁变化。
效果：构建时间减少约 40%，从原来的 80 秒缩短至 48 秒左右。

14、如何设计前端工程化体系（结合你 “jenkins 配置”“docker 部署” 的经验）？包括代码规范（eslint+pre-commit）、CI/CD 流程、环境隔离等。

结合项目经验，工程化体系包括：
代码规范：
统一开发方式：采用函数组件 + TypeScript，通过 ESLint（配置 eslint-config-react-app）和 Prettier 强制代码风格；
提交规范：使用 husky 的 pre-commit 钩子，通过 lint-staged 对暂存区代码执行 ESLint 检查，不通过则阻止提交。
CI/CD 流程：
用 Jenkins 创建流水线：拉取代码 → 安装依赖 → 执行测试 → 构建打包 → 推送 docker 镜像；
多环境部署：通过 docker 环境变量区分开发 / 测试 / 生产环境，动态注入 API 地址等配置。
环境隔离：开发环境用 webpack-dev-server 本地代理，测试 / 生产环境通过 docker 容器隔离，避免依赖冲突。

15、对模块化方案（ESM、CommonJS）的理解，在 Electron 项目中如何处理主进程与渲染进程的模块依赖？

模块化方案：ESM（ES 模块）是浏览器原生支持的模块化标准，通过 import/export 实现，静态分析；CommonJS 是 Node.js 的模块化方案，通过 require/module.exports 实现，动态加载。
Electron 中主进程与渲染进程的依赖处理：
主进程（Node 环境）使用 CommonJS，渲染进程（浏览器环境）使用 ESM；
共享代码（如工具函数）通过 babel 转换为兼容两种模块的格式，或用 rollup 打包为 UMD 格式；
避免在渲染进程中直接引用 Node 模块，通过 ipc 通信让主进程处理 Node 相关操作（如文件读写），保证渲染进程的浏览器兼容性。

16、你用 Electron 开发桌面端时，如何解决 “electron 代码迁移到网站前端” 的兼容性问题？（结合环境变量、ipc 函数替代方案等细节）

迁移 electron 代码到网站前端时，主要解决以下兼容问题：
环境区分：通过 process.env.NODE_ENV（Electron 中）和 window.\_\_IS_ELECTRON\_\_（网站中）标识环境，条件渲染样式（如 Electron 的窗口边框样式在网站中隐藏）；
ipc 替代：用冗余的 ipc 函数模拟 Electron 的 ipcRenderer，在网站环境中这些函数为空实现或调用 websocket 接口；
路径处理：Electron 的\_\_dirname 在网站中替换为 window.location.pathname，避免文件路径错误；
模块兼容：移除渲染进程中对 fs、path 等 Node 模块的直接引用，改为调用后端 API 获取文件数据。

17、对比 Electron 与其他跨端框架（如 RN、Taro）的技术差异，如果你需要适配鸿蒙系统，会从哪些方面入手？（岗位优先项）

技术差异：
Electron：基于 Chromium+Node.js，用 Web 技术开发桌面端，优势是生态成熟，劣势是包体积大；
RN/Taro：通过 JS 桥接原生组件，适合移动端，性能接近原生，但需维护多端适配逻辑。
鸿蒙适配思路：
先研究鸿蒙 ArkUI 框架的组件模型和状态管理方式，对比 React 的差异；
封装跨端组件库：将常用 UI 组件（如按钮、表格）抽象为适配层，根据环境渲染 ArkUI 或 React 组件；
通信层适配：用鸿蒙的@ohos.net.websocket 替代浏览器 websocket，保证数据交互逻辑一致；
逐步迁移：先适配核心功能（如数据展示），再优化性能和原生特性调用。

18、跨端项目中如何保证三端（iOS/Android/ 鸿蒙）的 UI 一致性和性能？你认为最大的挑战是什么？

UI 一致性：
制定统一设计规范：定义字号、颜色、间距等基础样式变量，通过 CSS 变量或主题文件共享；
使用跨端 UI 库：如 ant-design-mobile 适配多端，或自定义组件库保证渲染一致性。
性能保障：
按需加载：根据端类型（如 iOS/Android）加载对应优化的组件代码；
原生能力调用：复杂场景（如大数据表格）调用端原生 API，避免纯 JS 实现的性能瓶颈。
最大挑战：不同平台的渲染引擎差异（如鸿蒙的方舟引擎与浏览器的 WebKit），可能导致相同 CSS 在不同端表现不一致，需要大量针对性调试。

19、你了解哪些 AI 辅助前端开发的工具或场景？（如代码生成、自动化测试、性能分析）如果要在团队中落地 AI Coding，你会从哪个场景切入？（结合你 “开发效率提升” 的经验）

了解的工具 / 场景：
代码生成：GitHub Copilot 自动生成函数或组件代码；
自动化测试：AI 工具（如 Applitools）通过图像识别检测 UI 回归；
性能分析：基于 AI 的监控工具（如 Lighthouse AI）自动定位性能瓶颈。
落地切入点：结合开发效率提升经验，优先在 “自动化工具生成” 场景落地，例如：
开发 AI 辅助的表单配置工具，通过自然语言描述（如 “生成一个包含姓名、手机号的注册表单”）自动生成 JSON Schema，再通过现有转换工具生成表单项，减少手动编写配置的工作量。

20、你的项目中 “jsonstring-pack 工具” 压缩 JSON 的逻辑是什么？如果用 AI 模型优化压缩算法，你会怎么做？

压缩逻辑：
递归遍历多层嵌套的 JSON，识别重复键名和值（如多个对象都有"status": "pending"）；
建立映射表（如{ "status": 0, "pending": 1 }），用数字替代重复字符串；
去除空格和冗余引号，将 JSON 转换为紧凑格式（如{"a":1}→{a:1}）。
效果：某次测试中 9MB JSON 压缩至 500KB。
AI 优化思路：
训练基于 Transformer 的模型，学习 JSON 结构的规律（如键名的出现频率、嵌套层次特征），动态生成更优的压缩映射表；对非结构化数据（如长文本描述），用 AI 进行语义压缩，进一步减少体积。

21、如何看待 AI 对前端开发的影响？你认为前端工程师需要具备哪些 AI 相关技能？

影响：
效率提升：AI 辅助生成基础代码，减少重复劳动，前端工程师更聚焦逻辑设计和用户体验；
技术门槛变化：简单页面开发可能被自动化工具替代，复杂交互和跨端优化的需求增强。
所需技能：
提示词工程：能清晰描述需求，让 AI 生成更精准的代码；
模型基础认知：了解 AI 工具的局限性（如逻辑错误），能验证和修正生成结果；
跨领域学习：结合 AI 与前端工程化（如自动化测试、性能优化）的融合应用。

22、在 “协议模糊测试系统” 中，你用 protobuf 序列化数据减少 70% 传输量，具体是如何设计数据结构的？遇到过哪些兼容性问题？

数据结构设计：
在协议模糊测试系统中，针对固定结构的 ws 消息（如测试任务状态），定义 protobuf schema：

```js
message TaskStatus {
  required string taskId = 1;
  required int32 progress = 2; // 0-100
  optional string error = 3; // 错误信息，可选
}
```

字段用数字标识（1、2、3）减少传输量，通过 required/optional 控制必要性，实现结构化序列化。
兼容性问题：
新增字段时，老版本解析器可能忽略新增字段，导致数据丢失，解决方案：标记新增字段为 optional；
字段类型变更（如 int32 改为 string）会导致解析错误，通过版本号控制（如在消息头加入 version），不同版本用不同解析逻辑。

23、当你推动 “前端开发规范设计”（引入 TypeScript、eslint）时，如何说服团队接受？（体现沟通与组织能力）

共识建立：先组织团队讨论，结合项目痛点（如类组件维护困难、代码风格混乱），说明引入 TypeScript 和 ESLint 的必要性；
渐进式实施：不强制一次性改造所有代码，先从新功能开始使用函数组件 + TypeScript，再逐步迁移旧代码；
工具支持：编写迁移指南（如类组件转函数组件的步骤），开发自动化脚本（如批量替换 class 为函数组件）；
利益绑定：展示规范带来的实际收益（如测试通过率提升、bug 率下降），让团队感受到价值。

24、你未来想在跨端、AI、工程化哪个方向深入？如何通过技术带动团队成长？（匹配岗位 “技术追求” 要求）

深入方向：优先聚焦跨端开发与工程化，这与美团酒旅业务的多端适配需求高度契合，且能复用我在 Electron 和 Webpack 优化中的经验。
带动团队成长：
技术分享：定期组织跨端适配、工程化工具的实战分享，结合项目案例讲解（如 Electron 代码迁移经验）；
工具沉淀：将配置型表单、JSON 压缩等工具抽象为团队通用库，降低开发门槛；
规范迭代：根据团队反馈优化开发规范，建立 “提出问题 → 讨论方案 → 落地验证” 的良性循环，让技术进步伴随业务成长。

# 23 美团旅居 20250801 二面

**预测的题目**

## 🧩 一、Webpack & 前端工程化（8 题）

### 1. Webpack 的模块打包流程是怎样的？说说 Loader 和 Plugin 的执行机制。

**打包流程：**
1. **入口解析**：从 entry 配置开始，解析入口文件
2. **依赖收集**：递归解析 import/require 语句，构建依赖图
3. **Loader 处理**：对每个模块应用配置的 loader
4. **Plugin 处理**：在构建生命周期各阶段执行插件
5. **代码生成**：生成最终的 bundle 文件

**Loader 和 Plugin 机制：**
```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          'babel-loader', // 转换 ES6+ 语法
          'eslint-loader'  // 代码检查
        ]
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin(), // 生成 HTML 文件
    new MiniCssExtractPlugin() // 提取 CSS
  ]
}
```

**执行顺序：**
- Loader：从右到左，从下到上执行
- Plugin：在 webpack 构建的不同阶段触发（如 beforeRun、compile、emit 等）

### 2. Webpack 如何做 Tree Shaking？哪种模块语法支持？它的局限在哪里？

**Tree Shaking 原理：**
基于 ES Module 的静态分析，移除未使用的代码。

```javascript
// 支持 Tree Shaking 的写法
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// 使用方
import { add } from './math'; // 只打包 add 函数
```

**配置示例：**
```javascript
// webpack.config.js
module.exports = {
  mode: 'production', // 自动启用 Tree Shaking
  optimization: {
    usedExports: true,
    sideEffects: false
  }
}
```

**package.json 配置：**
```json
{
  "sideEffects": [
    "*.css",
    "*.scss"
  ]
}
```

**局限性：**
- 只支持 ES Module 语法
- 动态导入的模块无法分析
- 有副作用的模块会被保留
- 第三方库可能不支持

### 3. 如何优化大型项目的 Webpack 构建性能？

**多线程处理：**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: 4
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
}
```

**缓存优化：**
```javascript
module.exports = {
  cache: {
    type: 'filesystem', // webpack5 持久化缓存
    buildDependencies: {
      config: [__filename]
    }
  }
}
```

**其他优化措施：**
- DllPlugin：将第三方库单独打包，减少主包构建时间
- 持久化缓存（webpack5）：利用 filesystem cache
- 按需加载：路由懒加载、组件懒加载
- 减少 loader 数量和范围（exclude node_modules）
- 使用 resolve.alias 缩短查找路径

### 4. 如何实现多页面应用（MPA）的打包？和 SPA 有何不同？

**MPA 打包配置：**
```javascript
module.exports = {
  entry: {
    index: './src/index.js',
    about: './src/about.js',
    contact: './src/contact.js'
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './src/index.html',
      chunks: ['index']
    }),
    new HtmlWebpackPlugin({
      filename: 'about.html',
      template: './src/about.html',
      chunks: ['about']
    })
  ]
}
```

**与 SPA 区别：**
- **SPA**：单一入口和 HTML，前端路由控制页面切换
- **MPA**：多个入口和 HTML，后端路由控制页面切换
- **优势**：SEO 友好，首屏加载快，页面独立
- **劣势**：页面间切换会重新加载，资源无法共享

### 5. webpack5 的持久化缓存机制（Persistent Caching）原理？

**原理详解：**
- webpack5 引入 filesystem cache，将模块编译结果缓存到磁盘
- 通过文件内容哈希判断是否需要重新编译
- 下次构建时直接读取缓存，跳过未变更模块的编译

**配置示例：**
```javascript
module.exports = {
  cache: {
    type: 'filesystem',
    version: '1.0', // 缓存版本
    cacheDirectory: path.resolve(__dirname, '.webpack-cache'),
    buildDependencies: {
      config: [__filename], // 配置文件变更时失效缓存
      tsconfig: [path.resolve(__dirname, 'tsconfig.json')]
    }
  }
}
```

**性能提升：**
- 首次构建：正常速度
- 二次构建：速度提升 60-90%
- 适合大型项目，显著提升开发体验

### 6. 你是如何设计一套前端脚手架的？需要注意哪些可配置项？

**设计架构：**
```javascript
// cli.js
const inquirer = require('inquirer');
const fs = require('fs-extra');

async function createProject() {
  const answers = await inquirer.prompt([
    {
      type: 'list',
      name: 'framework',
      message: '选择框架',
      choices: ['React', 'Vue', 'Angular']
    },
    {
      type: 'confirm',
      name: 'typescript',
      message: '是否使用 TypeScript?'
    }
  ]);
  
  // 根据选择生成项目
  generateProject(answers);
}
```

**核心可配置项：**
- **项目类型**：SPA/MPA/组件库/Node.js
- **技术栈**：React/Vue/Angular + TypeScript
- **构建工具**：Webpack/Vite/Rollup
- **代码规范**：ESLint/Prettier/Stylelint
- **测试框架**：Jest/Vitest/Cypress
- **包管理器**：npm/yarn/pnpm
- **CI/CD**：GitHub Actions/GitLab CI
- **部署方案**：Vercel/Netlify/Docker

### 7. 介绍一下你项目中使用的 CI/CD 流程。

**完整流程：**
1. **代码提交**：push/merge request 触发
2. **代码检查**：ESLint/Prettier 检查
3. **单元测试**：Jest/Vitest 执行测试
4. **构建打包**：Webpack/Vite 构建
5. **部署发布**：自动部署到服务器

**GitHub Actions 配置：**
```yaml
name: CI/CD Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Build project
        run: npm run build
      
      - name: Deploy to production
        if: github.ref == 'refs/heads/main'
        run: npm run deploy
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
```

### 8. Monorepo 管理方式有哪些？你怎么看它的优势与劣势？

**主流工具对比：**

| 工具 | 特点 | 适用场景 |
|------|------|----------|
| Lerna | 老牌工具，发布管理强 | 传统项目迁移 |
| pnpm workspace | 性能好，节省空间 | 新项目推荐 |
| Nx | 智能构建，缓存优化 | 大型企业项目 |
| Rush | 微软出品，企业级 | 超大规模项目 |

**pnpm workspace 配置：**
```json
// pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'apps/*'

// package.json
{
  "scripts": {
    "build": "pnpm -r run build",
    "test": "pnpm -r run test"
  }
}
```

**优势：**
- **依赖统一**：避免版本冲突，减少重复安装
- **代码复用**：共享组件库、工具函数
- **原子发布**：相关包同步发布，避免版本不一致
- **开发效率**：统一构建、测试、部署流程
- **团队协作**：代码审查、知识共享更容易

**劣势：**
- **复杂度增加**：依赖关系复杂，调试困难
- **构建时间**：项目大时，全量构建耗时
- **权限管理**：不同团队对不同包的权限控制
- **学习成本**：团队需要适应新的开发模式

## ⚛️ 二、React 原理与应用（8 题）

### 9. React 中函数组件是如何实现状态管理的？useState 底层做了什么？

**Hook 链表原理：**
React 通过 Fiber 节点上的 memoizedState 属性维护 Hook 链表，每个 Hook 节点包含：
- `memoizedState`：当前状态值
- `baseState`：基础状态
- `queue`：更新队列
- `next`：指向下一个 Hook

**简化实现：**
```javascript
let currentFiber = null;
let hookIndex = 0;

function useState(initialState) {
  const currentHook = currentFiber.memoizedState?.[hookIndex] || {
    memoizedState: initialState,
    queue: []
  };
  
  // 处理更新队列
  currentHook.queue.forEach(update => {
    currentHook.memoizedState = update(currentHook.memoizedState);
  });
  currentHook.queue = [];
  
  const setState = (newState) => {
    const update = typeof newState === 'function' ? newState : () => newState;
    currentHook.queue.push(update);
    scheduleUpdate(); // 触发重新渲染
  };
  
  currentFiber.memoizedState[hookIndex] = currentHook;
  hookIndex++;
  
  return [currentHook.memoizedState, setState];
}
```

**关键机制：**
- **顺序依赖**：Hook 必须按相同顺序调用
- **批量更新**：多个 setState 会合并为一次更新
- **函数式更新**：`setState(prev => prev + 1)` 避免闭包陷阱

### 10. React 的调和（Reconciliation）机制具体做了哪些优化？

**Diff 算法优化：**

1. **树层级比较**：只比较同层节点，时间复杂度 O(n)
2. **组件类型判断**：不同类型直接替换，相同类型递归比较
3. **Key 匹配机制**：通过 key 快速定位可复用节点

**具体实现：**
```javascript
// 伪代码：Diff 算法核心逻辑
function reconcileChildren(currentFiber, newChildren) {
  let oldFiber = currentFiber.child;
  let newIdx = 0;
  
  // 第一轮：处理相同位置的节点
  while (oldFiber && newIdx < newChildren.length) {
    const newChild = newChildren[newIdx];
    
    if (oldFiber.key === newChild.key && oldFiber.type === newChild.type) {
      // 可复用，更新 props
      const newFiber = createFiber(newChild, oldFiber);
      newFiber.alternate = oldFiber;
      newIdx++;
      oldFiber = oldFiber.sibling;
    } else {
      break; // 位置不匹配，进入第二轮
    }
  }
  
  // 第二轮：处理移动、新增、删除
  const existingChildren = mapRemainingChildren(oldFiber);
  
  while (newIdx < newChildren.length) {
    const newChild = newChildren[newIdx];
    const matchedFiber = existingChildren.get(newChild.key);
    
    if (matchedFiber) {
      // 找到匹配节点，标记移动
      existingChildren.delete(newChild.key);
    } else {
      // 新节点，标记插入
    }
    newIdx++;
  }
  
  // 剩余的旧节点标记删除
  existingChildren.forEach(child => {
    deleteChild(child);
  });
}
```

**性能优化策略：**
- **最小 DOM 操作**：只更新变化的属性
- **批量更新**：收集所有变更，一次性应用
- **优先级调度**：高优先级更新可中断低优先级

### 11. 什么是 React Fiber？它解决了 React16 前什么问题？

**Fiber 架构：**
Fiber 是一种基于链表的数据结构，每个 Fiber 节点代表一个组件或 DOM 元素。

**Fiber 节点结构：**
```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 节点信息
  this.tag = tag;                    // 节点类型
  this.key = key;                    // React key
  this.type = null;                  // 组件类型
  
  // 树结构
  this.child = null;                 // 第一个子节点
  this.sibling = null;               // 下一个兄弟节点
  this.return = null;                // 父节点
  
  // 状态
  this.memoizedState = null;         // 当前状态
  this.pendingProps = pendingProps;  // 新的 props
  this.memoizedProps = null;         // 当前 props
  
  // 调度
  this.expirationTime = NoWork;      // 过期时间
  this.alternate = null;             // 双缓存
}
```

**解决的问题：**

1. **长任务阻塞**：React15 递归更新会阻塞主线程
2. **无法中断**：一旦开始更新就必须完成
3. **优先级缺失**：无法区分紧急和非紧急更新

**Fiber 的优势：**
```javascript
// 可中断的渲染过程
function workLoop(deadline) {
  let shouldYield = false;
  
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    shouldYield = deadline.timeRemaining() < 1;
  }
  
  if (nextUnitOfWork) {
    // 还有工作，下次继续
    requestIdleCallback(workLoop);
  } else {
    // 工作完成，提交更新
    commitRoot();
  }
}
```

### 12. React 的批处理更新是如何工作的？在哪些情况下会失效？

**批处理机制：**
React 通过 `isBatchingUpdates` 标志控制是否批处理更新。

**工作原理：**
```javascript
// 简化的批处理逻辑
let isBatchingUpdates = false;
const updateQueue = [];

function setState(newState) {
  if (isBatchingUpdates) {
    updateQueue.push(newState);
  } else {
    // 立即更新
    performUpdate(newState);
  }
}

function batchedUpdates(fn) {
  const prevIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  
  try {
    fn();
  } finally {
    isBatchingUpdates = prevIsBatchingUpdates;
    if (!isBatchingUpdates && updateQueue.length > 0) {
      flushUpdates();
    }
  }
}
```

**批处理场景：**
```javascript
// ✅ 会批处理
function handleClick() {
  setCount(count + 1);    // 不会立即重渲染
  setValue(value + 1);    // 不会立即重渲染
  // 批量执行，只渲染一次
}

// ❌ 不会批处理（React 17 及之前）
function handleClick() {
  setTimeout(() => {
    setCount(count + 1);  // 立即重渲染
    setValue(value + 1);  // 立即重渲染
  }, 0);
}

// ✅ React 18 自动批处理
function handleClick() {
  setTimeout(() => {
    setCount(count + 1);  // 会批处理
    setValue(value + 1);  // 会批处理
  }, 0);
}
```

**React 18 改进：**
- 默认启用自动批处理
- 使用 `flushSync` 强制同步更新

```javascript
import { flushSync } from 'react-dom';

flushSync(() => {
  setCount(count + 1);
});
// DOM 已同步更新
```

### 13. useEffect 和 useLayoutEffect 的本质区别？你遇到过什么实际问题？

**执行时机对比：**

```
浏览器渲染流程：
DOM 变更 → 样式计算 → 布局 → 绘制 → 合成
         ↑                    ↑
   useLayoutEffect        useEffect
```

**具体区别：**
```javascript
function Component() {
  const [width, setWidth] = useState(0);
  
  // ❌ 使用 useEffect 会闪烁
  useEffect(() => {
    const element = document.getElementById('box');
    setWidth(element.offsetWidth);
  }, []);
  
  // ✅ 使用 useLayoutEffect 不会闪烁
  useLayoutEffect(() => {
    const element = document.getElementById('box');
    setWidth(element.offsetWidth);
  }, []);
  
  return <div id="box" style={{ width: width > 100 ? '200px' : '50px' }} />;
}
```

**实际问题案例：**

1. **DOM 测量闪烁**：
```javascript
// 问题：测量 DOM 尺寸时会闪烁
function Tooltip() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useLayoutEffect(() => {
    // 同步测量，避免闪烁
    const rect = tooltipRef.current.getBoundingClientRect();
    setPosition(calculatePosition(rect));
  });
}
```

2. **动画初始化**：
```javascript
// 需要在绘制前设置初始状态
useLayoutEffect(() => {
  gsap.set(elementRef.current, { opacity: 0, y: 20 });
}, []);
```

**选择原则：**
- 需要同步读取/修改 DOM → `useLayoutEffect`
- 副作用操作（请求、订阅）→ `useEffect`

### 14. React 中的 Context 是怎么工作的？为什么会导致性能问题？怎么优化？

**Context 工作原理：**
```javascript
// Context 创建和使用
const ThemeContext = React.createContext();

function App() {
  const [theme, setTheme] = useState('light');
  
  // 每次 theme 变化，所有消费者都会重渲染
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
      <Main />
      <Footer />
    </ThemeContext.Provider>
  );
}

function Header() {
  const { theme } = useContext(ThemeContext);
  return <header className={theme}>Header</header>;
}
```

**性能问题原因：**
1. **全量更新**：Context value 变化时，所有消费者都重渲染
2. **对象引用**：每次渲染创建新对象，导致不必要的更新
3. **深层传递**：中间组件也会重渲染

**优化策略：**

1. **拆分 Context**：
```javascript
// 将数据和操作分离
const ThemeStateContext = React.createContext();
const ThemeDispatchContext = React.createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeStateContext.Provider value={theme}>
      <ThemeDispatchContext.Provider value={setTheme}>
        {children}
      </ThemeDispatchContext.Provider>
    </ThemeStateContext.Provider>
  );
}
```

2. **使用 useMemo 缓存 value**：
```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const value = useMemo(() => ({
    theme,
    setTheme
  }), [theme]);
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

3. **组件级优化**：
```javascript
const Header = React.memo(function Header() {
  const { theme } = useContext(ThemeContext);
  return <header className={theme}>Header</header>;
});
```

### 15. 如何实现一个自己的 usePrevious Hook？

**基础实现：**
```javascript
import { useRef, useEffect } from 'react';

function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// 使用示例
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>当前值: {count}</p>
      <p>上一次值: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

**增强版本：**
```javascript
function usePrevious(value, initialValue) {
  const ref = useRef(initialValue);
  const prevRef = useRef();
  
  useEffect(() => {
    prevRef.current = ref.current;
    ref.current = value;
  });
  
  return prevRef.current;
}

// 支持比较函数的版本
function usePreviousDistinct(value, compare = Object.is) {
  const prevRef = useRef();
  const curRef = useRef();
  
  if (!compare(curRef.current, value)) {
    prevRef.current = curRef.current;
    curRef.current = value;
  }
  
  return prevRef.current;
}
```

**实际应用场景：**
```javascript
// 监听变化
function useChangeLogger(value, name) {
  const prevValue = usePrevious(value);
  
  useEffect(() => {
    if (prevValue !== undefined && prevValue !== value) {
      console.log(`${name} changed from ${prevValue} to ${value}`);
    }
  }, [value, prevValue, name]);
}

// 动画过渡
function AnimatedCounter({ count }) {
  const prevCount = usePrevious(count);
  const isIncreasing = count > (prevCount ?? 0);
  
  return (
    <div className={isIncreasing ? 'increase' : 'decrease'}>
      {count}
    </div>
  );
}
```

### 16. React 中如何做组件懒加载和代码分割？

**基础懒加载：**
```javascript
import React, { Suspense } from 'react';

// 动态导入组件
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

**路由级别分割：**
```javascript
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));
const Contact = React.lazy(() => import('./pages/Contact'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading page...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

**条件懒加载：**
```javascript
function AdminPanel() {
  const [showAdmin, setShowAdmin] = useState(false);
  const [AdminComponent, setAdminComponent] = useState(null);
  
  const loadAdmin = async () => {
    const { default: Admin } = await import('./Admin');
    setAdminComponent(() => Admin);
    setShowAdmin(true);
  };
  
  return (
    <div>
      {!showAdmin && (
        <button onClick={loadAdmin}>
          Load Admin Panel
        </button>
      )}
      {showAdmin && AdminComponent && <AdminComponent />}
    </div>
  );
}
```

**预加载优化：**
```javascript
// 预加载组件
const preloadComponent = (componentImport) => {
  const Component = React.lazy(componentImport);
  Component.preload = componentImport;
  return Component;
};

const LazyComponent = preloadComponent(() => import('./LazyComponent'));

// 在用户可能需要时预加载
function HomePage() {
  useEffect(() => {
    // 鼠标悬停时预加载
    const link = document.querySelector('[data-preload="lazy"]');
    link?.addEventListener('mouseenter', LazyComponent.preload);
    
    return () => {
      link?.removeEventListener('mouseenter', LazyComponent.preload);
    };
  }, []);
}
```

**错误边界处理：**
```javascript
class LazyErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Lazy loading error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <div>组件加载失败，请刷新重试</div>;
    }
    
    return this.props.children;
  }
}

// 使用
<LazyErrorBoundary>
  <Suspense fallback={<Loading />}>
    <LazyComponent />
  </Suspense>
</LazyErrorBoundary>
```

## 🛠️ 三、综合能力 & 工程实践（4 题）

### 17. 前端埋点系统如何设计？如何收集并上报用户行为数据？

**系统架构设计：**
```javascript
class Analytics {
  constructor(config) {
    this.config = config;
    this.queue = [];
    this.isOnline = navigator.onLine;
    this.init();
  }
  
  init() {
    this.autoTrack();
    this.listenNetworkStatus();
    this.startBatchReport();
  }
  
  // 自动埋点
  autoTrack() {
    this.trackPageView();
    this.trackClicks();
    this.trackFormSubmits();
    this.trackErrors();
  }
  
  // 页面浏览埋点
  trackPageView() {
    const data = {
      type: 'pageview',
      url: location.href,
      title: document.title,
      referrer: document.referrer,
      timestamp: Date.now(),
      userId: this.getUserId(),
      sessionId: this.getSessionId()
    };
    this.track(data);
  }
  
  // 点击埋点
  trackClicks() {
    document.addEventListener('click', (e) => {
      const target = e.target;
      const data = {
        type: 'click',
        element: target.tagName.toLowerCase(),
        text: target.textContent?.slice(0, 100),
        className: target.className,
        id: target.id,
        xpath: this.getXPath(target),
        timestamp: Date.now()
      };
      this.track(data);
    });
  }
  
  // 批量上报
  async sendBatch() {
    if (this.queue.length === 0) return;
    
    const data = this.queue.splice(0, 10);
    
    try {
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.config.endpoint, JSON.stringify(data));
      } else {
        await fetch(this.config.endpoint, {
          method: 'POST',
          body: JSON.stringify(data),
          headers: { 'Content-Type': 'application/json' }
        });
      }
    } catch (error) {
      this.queue.unshift(...data);
      console.error('Analytics send failed:', error);
    }
  }
}

// 使用示例
const analytics = new Analytics({
  endpoint: 'https://api.example.com/analytics',
  userId: 'user123'
});

analytics.track('button_click', {
  button_name: 'purchase',
  product_id: 'prod123',
  price: 99.99
});
```

**数据收集策略：**
1. **全埋点**：自动收集所有用户行为
2. **可视化埋点**：通过界面配置埋点
3. **代码埋点**：手动添加埋点代码
4. **无埋点**：通过 SDK 自动收集

### 18. 如何在项目中做权限控制？前端怎么保障路由、组件级权限？

**权限系统设计：**
```javascript
// 权限管理 Hook
function useAuth() {
  const [user, setUser] = useState(null);
  const [permissions, setPermissions] = useState([]);
  const [roles, setRoles] = useState([]);
  
  const hasPermission = useCallback((permission) => {
    return permissions.includes(permission);
  }, [permissions]);
  
  const hasRole = useCallback((role) => {
    return roles.includes(role);
  }, [roles]);
  
  return {
    user,
    permissions,
    roles,
    hasPermission,
    hasRole,
    isAuthenticated: !!user
  };
}
```

**路由权限控制：**
```javascript
// 路由守卫组件
function ProtectedRoute({ children, requiredPermissions = [], requiredRoles = [] }) {
  const { isAuthenticated, hasPermission, hasRole } = useAuth();
  const navigate = useNavigate();
  
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login');
      return;
    }
    
    // 检查权限
    const hasRequiredPermissions = requiredPermissions.every(hasPermission);
    const hasRequiredRoles = requiredRoles.length === 0 || requiredRoles.some(hasRole);
    
    if (!hasRequiredPermissions || !hasRequiredRoles) {
      navigate('/403');
    }
  }, [isAuthenticated, requiredPermissions, requiredRoles]);
  
  return children;
}

// 路由配置
function App() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route path="/403" element={<Forbidden />} />
      
      <Route path="/admin" element={
        <ProtectedRoute requiredRoles={['admin']}>
          <AdminPanel />
        </ProtectedRoute>
      } />
      
      <Route path="/users" element={
        <ProtectedRoute requiredPermissions={['user:read']}>
          <UserList />
        </ProtectedRoute>
      } />
    </Routes>
  );
}
```

**组件级权限控制：**
```javascript
// 权限包装组件
function PermissionWrapper({ 
  children, 
  permissions = [], 
  roles = [], 
  fallback = null
}) {
  const { hasPermission, hasRole } = useAuth();
  
  const hasRequiredPermissions = permissions.length === 0 || permissions.some(hasPermission);
  const hasRequiredRoles = roles.length === 0 || roles.some(hasRole);
  
  const hasAccess = hasRequiredPermissions && hasRequiredRoles;
  
  return hasAccess ? children : fallback;
}

// 使用示例
function UserManagement() {
  return (
    <div>
      <h1>用户管理</h1>
      
      <PermissionWrapper permissions={['user:create']}>
        <button>添加用户</button>
      </PermissionWrapper>
      
      <PermissionWrapper roles={['admin', 'super_admin']}>
        <button>删除用户</button>
      </PermissionWrapper>
    </div>
  );
}
```

### 19. 开发中如何定位和优化前端性能瓶颈？

**性能监控体系：**
```javascript
// 性能监控类
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.init();
  }
  
  init() {
    this.observeWebVitals();
    this.observeLongTasks();
    this.observeMemoryUsage();
  }
  
  // 监控 Web Vitals
  observeWebVitals() {
    // First Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.name === 'first-contentful-paint') {
          this.report('fcp', entry.startTime);
        }
      });
    }).observe({ entryTypes: ['paint'] });
    
    // Largest Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.report('lcp', lastEntry.startTime);
    }).observe({ entryTypes: ['largest-contentful-paint'] });
  }
  
  // 长任务监控
  observeLongTasks() {
    new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        this.report('long-task', {
          duration: entry.duration,
          startTime: entry.startTime
        });
      });
    }).observe({ entryTypes: ['longtask'] });
  }
  
  report(metric, value) {
    console.log(`Performance metric: ${metric}`, value);
  }
}
```

**性能优化策略：**
```javascript
// 图片懒加载
function LazyImage({ src, alt, ...props }) {
  const [imageSrc, setImageSrc] = useState('');
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return <img ref={imgRef} src={imageSrc} alt={alt} {...props} />;
}

// 虚拟滚动
function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  
  const visibleItems = items.slice(startIndex, endIndex);
  
  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, index) => (
          <div
            key={startIndex + index}
            style={{
              position: 'absolute',
              top: (startIndex + index) * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          >
            {item}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 20. 说说你在项目中遇到过的一次技术难题，以及你的解决过程。

**案例：大型表格性能优化**

**问题背景：**
在一个数据管理平台中，需要展示包含 10 万+ 行数据的表格，每行包含 20+ 列。初始实现导致页面卡顿严重，滚动不流畅，内存占用过高。

**问题分析：**
1. **DOM 节点过多**：10万行 × 20列 = 200万个 DOM 节点
2. **内存占用**：所有数据同时渲染，内存占用超过 500MB
3. **渲染阻塞**：大量 DOM 操作阻塞主线程
4. **事件监听**：每个单元格都有点击事件，事件监听器过多

**解决方案：**

1. **实现虚拟滚动：**
```javascript
function VirtualTable({ data, columns, rowHeight = 40 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(600);
  
  // 计算可见行范围
  const startIndex = Math.floor(scrollTop / rowHeight);
  const visibleCount = Math.ceil(containerHeight / rowHeight) + 2;
  const endIndex = Math.min(startIndex + visibleCount, data.length);
  
  // 只渲染可见行
  const visibleData = data.slice(startIndex, endIndex);
  
  const handleScroll = useCallback(
    throttle((e) => {
      setScrollTop(e.target.scrollTop);
    }, 16), // 60fps
    []
  );
  
  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: data.length * rowHeight }}>
        <div
          style={{
            transform: `translateY(${startIndex * rowHeight}px)`,
            position: 'absolute',
            width: '100%'
          }}
        >
          {visibleData.map((row, index) => (
            <TableRow
              key={startIndex + index}
              data={row}
              columns={columns}
              height={rowHeight}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
```

2. **事件委托优化：**
```javascript
function VirtualTable({ data, onCellClick }) {
  const handleTableClick = useCallback((e) => {
    const cell = e.target.closest('.table-cell');
    if (cell) {
      const rowIndex = parseInt(cell.dataset.rowIndex);
      const colIndex = parseInt(cell.dataset.colIndex);
      onCellClick?.(rowIndex, colIndex, data[rowIndex]);
    }
  }, [data, onCellClick]);
  
  return (
    <div onClick={handleTableClick}>
      {/* 表格内容 */}
    </div>
  );
}
```

**最终效果：**
- **内存占用**：从 500MB+ 降至 50MB 以内
- **渲染性能**：60fps 流畅滚动
- **首屏时间**：从 3s+ 降至 300ms
- **交互响应**：点击响应时间 < 100ms

**经验总结：**
1. **虚拟化是关键**：只渲染可见区域
2. **事件委托**：减少事件监听器数量
3. **缓存策略**：合理的数据缓存机制
4. **性能监控**：实时监控性能指标
5. **渐进优化**：先解决最大瓶颈，再优化细节
