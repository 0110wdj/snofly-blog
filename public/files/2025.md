# 1 京东零售 20250326 一面

1. 登录之后，url 访问无权限页面，如何处理？

   - api 请求权限，api 返回之前，处于 loading 状态
   - api 返回之后，跳转到 404 页面

2. 随机打乱数组元素？

3. 怎么提高渲染效率？

4. 大量运算，js 卡 ui，怎么处理？

5. HTTP 2.0 特性？

6. http 301 302？

7. 指导新人，规范风格统一？

   - 插件同步：工作区 extensions.json 配置

8. 我的压缩算法实现原理

9. npm、pnpm、yarn 区别？

10. css 居中？

11. css 动画实现 loading 效果？

# 2 贝壳找房 20250331 一面

1. 性能优化

   - 加载性能

     - FCP（First Contentful Paint）：首个内容绘制时间，页面首次有内容渲染的时间
     - LCP（Largest Contentful Paint）：最大内容绘制时间，页面中最大可视内容渲染完成的时间，理想值 < 2.5 秒
     - TTFB（Time to First Byte）：首字节到达时间，衡量服务端响应速度
     - FP（First Paint）：首次绘制时间，浏览器开始绘制像素的时间

   - 交互性能

     - FID（First Input Delay）：首次输入延迟，衡量用户首次交互的响应时间，理想值 < 100 毫秒
     - INP（Interaction to Next Paint）：交互到下一次绘制的延迟，衡量用户操作后的响应速度

   - 页面稳定性

     - CLS（Cumulative Layout Shift）：累积布局偏移量，衡量视觉稳定性，理想值 < 0.1

   - 网络性能

     - DNS Lookup Time：DNS 解析时间
     - TCP Connect Time：TCP 连接时间
     - TLS Handshake Time：TLS 握手时间
     - Resource Load Time：资源加载时间

   - 渲染性能
     - FPS（Frames Per Second）：每秒帧数，理想保持在 60 FPS
     - Layout Time：页面布局计算时间
     - Paint Time：页面绘制时间
     - Compositing Time：合成层的时间

2. createPortal

- ReactDOM.createPortal 用于将子组件渲染到指定的 DOM 节点之外。
- 作用：常用于模态框、弹窗等需要在父组件之外渲染的场景。

```jsx
import React from "react";
import ReactDOM from "react-dom";

function Modal({ children }) {
  return ReactDOM.createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("modal-root")
  );
}
```

3. 写一个 new Layout("小明").eat("水果").sleep(5).eat("水") 类或者函数，能够链式调用。

```js
class Layout {
  constructor(name) {
    this.name = name;
    this.queue = [];
    console.log(`${this.name} 创建了 Layout`);
    setTimeout(() => this.runQueue(), 0);
  }

  eat(food) {
    this.queue.push(() => console.log(`${this.name} 正在吃 ${food}`));
    return this;
  }

  sleep(seconds) {
    this.queue.push(() => {
      console.log(`${this.name} 开始睡觉 ${seconds} 秒`);
      const start = Date.now();
      while (Date.now() - start < seconds * 1000) {}
      console.log(`${this.name} 睡醒了`);
    });
    return this;
  }

  runQueue() {
    if (this.queue.length > 0) {
      const task = this.queue.shift();
      task();
      setTimeout(() => this.runQueue(), 0);
    }
  }
}

// 使用示例
new Layout("小明").eat("水果").sleep(5).eat("水");
```

4. 写一个 Promise.all

```js
function PromiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = [];
    let completedCount = 0; // 记录已完成的 Promise 数量
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          completedCount++;
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch((reason) => {
          reject(reason); // 只要有一个 Promise 失败，直接 reject
        });
    });
  });
}
```

# 3 学堂在线 20250415 笔试、一面、二面

1、js 数组有哪些方法；
2、编程：实现任意角度的扇形；
3、编程：实现简单的发布订阅模式；
4、编程：实现简单的 promise；
5、编程：实现一个过滤框，下方展示过滤后的列表；
6、proxy 理解；
7、vue 按钮权限控制；
8、http 常见状态码、请求方法、含义；
9、浏览器缓存；

# 4 元保集团 20250421 一面

# 5 京东 20250421 一面

# 6 百度 20250421 一面

# 7 美团 20250421 一面

# 8 并集科技 20250423 一面

# 9 元保集团 20250425 二面

# 10 百度无人车 20250428 一面

# 11 百度无人车 20250429 二面

# 12 百度无人车 20250507 三面

# 13 百度无人车 20250508 四面

# 14 百度在线 20250610 一面

# 15 百度在线 20250616 二面

# 16 快手 20250619 一面

# 17 百度在线 20250624 三面

# 18 百度文库 20250627 一面

# 19 百度文库 20250701 二面

# 20 顺丰 20250715 一面

# 21 百度在线 20250724 一面

# 22 美团旅居 20250731 一面

**预测的题目**

1、请解释闭包的原理及实际应用场景，结合你的项目举例说明（比如组件封装或工具函数中是否用到）
闭包是指函数及其捆绑的周边状态（词法环境）的引用的组合，其核心原理是函数在定义时可以访问外层函数的变量，且当外层函数执行完毕后，内层函数仍能访问这些变量。  
实际应用场景包括：封装私有变量、实现模块化工具函数等。在开发`jsonstring-pack`工具时，我利用闭包封装了 JSON 压缩的核心逻辑，将递归处理多层嵌套结构的方法与临时缓存变量（如压缩映射表）绑定，避免了全局变量污染，同时保证了压缩过程中数据处理的连续性。

2、手写 Promise.allSettled 实现，需要处理异步任务的所有结果（成功 / 失败）

```javascript
Promise.myAllSettled = function (promises) {
  return new Promise((resolve) => {
    if (!Array.isArray(promises)) {
      return resolve([
        { status: "rejected", reason: new TypeError("参数必须是数组") },
      ]);
    }
    const result = [];
    let count = 0;
    promises.forEach((p, index) => {
      Promise.resolve(p).then(
        (value) => {
          result[index] = { status: "fulfilled", value };
          count++;
          if (count === promises.length) resolve(result);
        },
        (reason) => {
          result[index] = { status: "rejected", reason };
          count++;
          if (count === promises.length) resolve(result);
        }
      );
    });
  });
};
```

3、如何实现一个带并发限制的异步调度器？例如限制同时运行的 Promise 数量为 3

```js
class Scheduler {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  add(promiseCreator) {
    return new Promise((resolve) => {
      this.queue.push({ promiseCreator, resolve });
      this.run();
    });
  }

  run() {
    if (this.running >= this.limit || this.queue.length === 0) return;
    this.running++;
    const { promiseCreator, resolve } = this.queue.shift();
    promiseCreator()
      .then((result) => {
        resolve(result);
        this.running--;
        this.run();
      })
      .catch((err) => {
        resolve(err); // 捕获错误，保证调度继续
        this.running--;
        this.run();
      });
  }
}
```

4、解释原型链与继承，手写一个基于 class 的继承案例（结合你用 React 函数组件的经验，对比 class 组件的继承逻辑）。
原型链是 JavaScript 中实现继承的基础，每个对象都有\_\_proto\_\_属性指向其原型对象，原型对象的\_\_proto\_\_又指向更上层原型，最终指向 null，形成链式结构。

基于 class 的继承案例：

```js
// 父类：基础组件
class BaseComponent {
  constructor(name) {
    this.name = name;
  }
  logName() {
    console.log(`Component name: ${this.name}`);
  }
}

// 子类：表单组件（继承基础组件）
class FormComponent extends BaseComponent {
  constructor(name, fields) {
    super(name);
    this.fields = fields;
  }
  renderFields() {
    console.log(`Rendering fields: ${this.fields.join(",")}`);
  }
}

// React场景对比：类组件依赖继承，函数组件通过组合（Hooks）复用逻辑
// 类组件可能通过extends React.Component实现继承，而函数组件用useState等Hooks拆分逻辑，更灵活
```

5、手写数组去重（考虑对象、NaN 等特殊情况），并优化时间复杂度。

```js
function uniqueArray(arr) {
  const map = new Map();
  return arr.filter((item) => {
    // 处理NaN（Map中NaN视为相等）
    if (Number.isNaN(item)) {
      if (!map.has("NaN")) {
        map.set("NaN", true);
        return true;
      }
      return false;
    }
    // 处理对象（基于引用）
    if (typeof item === "object" && item !== null) {
      const key = JSON.stringify(item); // 简单对象可用，复杂对象需优化
      if (!map.has(key)) {
        map.set(key, true);
        return true;
      }
      return false;
    }
    // 基本类型
    if (!map.has(item)) {
      map.set(item, true);
      return true;
    }
    return false;
  });
}
// 时间复杂度O(n)，空间复杂度O(n)，通过Map实现一次遍历去重
```

6、实现一个 LRU 缓存机制（结合你 “大型表格缓存字段数据” 的经验）。

结合大型表格缓存字段数据的经验，LRU（最近最少使用）缓存核心是淘汰最久未使用的数据：

```js
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map(); // 利用Map的插入顺序特性
  }

  get(key) {
    if (!this.cache.has(key)) return -1;
    const value = this.cache.get(key);
    // 访问后移到最新位置
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key); // 已存在则先删除
    } else if (this.cache.size >= this.capacity) {
      // 超过容量，删除最旧的（Map的第一个元素）
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(key, value); // 插入新值（最新位置）
  }
}
// 在菱电TBOX车联网平台的大型表格中，类似逻辑用于缓存高频访问的字段数据，减少重复渲染计算
```

7、如何检测并修复前端代码中的内存泄漏？举例说明你遇到过的场景（比如 Electron 跨端项目中是否有类似问题）。

内存泄漏常见场景：未清理的事件监听、闭包中引用的 DOM 未释放、定时器未清除等。
在 Electron 项目中，曾遇到过 ipc 通信的回调函数未正确解绑导致的泄漏：当窗口关闭后，ipcRenderer.on 注册的监听仍被引用，导致窗口实例无法被 GC 回收。
解决方式：在组件卸载或窗口关闭时，通过 ipcRenderer.removeListener 手动移除监听；对长期存在的 websocket 连接，在断开时清除所有回调函数，避免引用残留。

8、解释 React 的虚拟 DOM 与 Diff 算法原理，你在 “10 + 万行大型表格” 中是如何通过虚拟滚动优化性能的？具体实现逻辑是什么？

虚拟 DOM：是 React 对真实 DOM 的内存映射，通过 JS 对象描述 DOM 结构，避免频繁操作真实 DOM 的性能开销。
Diff 算法：React 采用分层比较（同层节点对比）、列表节点用 key 标识避免全量对比，降低复杂度。
在 10 + 万行大型表格优化中，虚拟滚动的实现逻辑：
计算可视区域高度与每行高度，确定可视范围内的行索引（如滚动到第 500 行，可视区显示 500-600 行）；
只渲染可视区的行 DOM，非可视区用空白 div 占位（撑开滚动高度）；
监听滚动事件，动态更新可视区行索引并重新渲染对应行，同时复用已创建的 DOM 节点减少创建开销；
结合字段数据缓存，避免重复计算单元格内容，进一步减少渲染压力。

9、Hooks 的设计原理是什么？为什么函数组件比类组件更适合配合 Hooks 使用？你在 “前端开发规范设计” 中迁移类组件到函数组件时遇到过哪些坑？

Hooks 设计原理：基于闭包和链表存储状态，将组件状态与副作用从组件生命周期中抽离，实现逻辑复用。每次渲染时，Hooks 按调用顺序关联对应的状态，因此要求 Hooks 不能在条件语句中调用。
函数组件更适合 Hooks：函数组件本质是纯函数，没有 this 指向问题，Hooks 的状态管理逻辑（如 useState）与函数组件的调用上下文天然契合；而类组件依赖 this.state 和生命周期方法，逻辑分散且复用困难。
迁移类组件到函数组件时的坑：
this 指向丢失：类组件中 this.handleClick = this.handleClick.bind(this)的逻辑需改为箭头函数或直接在 Hooks 中定义；
生命周期映射问题：componentDidMount 与 componentDidUpdate 合并为 useEffect，需注意依赖数组的设置，避免无限循环；
状态更新逻辑：类组件的 setState 是合并更新，而 useState 的更新函数是替换，需手动处理对象类型状态的合并。

10、如何设计一个可复用的表单组件（结合你 “配置型表单组件” 的经验），需要考虑哪些扩展性和性能问题？

结合 WFUZZ 项目的配置型表单组件经验，设计思路：
基于 JSON Schema 驱动：通过转换工具读取 JSON 配置（包含字段类型、校验规则、UI 属性等），自动生成表单项；
组件分层设计：拆分为 Form（容器）、FormItem（单项包装）、FormControl（输入控件，如 Input/Select），通过 Context 传递表单状态；
扩展性考虑：支持自定义控件注册（如特殊日期选择器）、动态增减表单项、嵌套表单（通过递归解析 JSON）；
性能优化：使用 useMemo 缓存生成的表单项配置，useCallback 缓存 onChange 回调，避免因父组件重渲染导致的不必要更新。

11、在跨端项目（如你的 Electron 应用）中，如何处理前端与后端 / 其他端的状态同步？你用 “预定义对象结构 + websocket 更新” 的方案相比传统状态管理（如 Redux）有什么优势？

在 Electron 项目中，前端与 rust 工具端的状态同步方案：
预定义双方一致的数据结构（如{ id: string, status: string, config: object }）；
通过 websocket 实时发送状态更新操作（如{ type: 'update', path: 'status', value: 'running' }）；
前端维护本地状态对象，接收更新操作后通过路径（如 status）定位并修改对应字段，保证两端状态一致。
相比 Redux 的优势：
轻量性：无需引入复杂的 action/reducer 机制，适合跨端间的简单状态同步；
实时性：基于 websocket 的推送模式，比 Redux 的单向数据流更高效；
针对性：为跨端场景设计，避免 Redux 中全局状态树可能导致的冗余。

12、解释 React Context 的使用场景及性能瓶颈，你在项目中是否用过？如果用，如何避免不必要的重渲染？

使用场景：适合全局共享少量稳定数据（如主题配置、用户信息），避免 props 多层传递（“props drilling”）。
性能瓶颈：当 Context 的值变化时，所有消费该 Context 的组件都会重渲染，即染，即使只用到 Context 中的部分数据。
项目中未直接使用 Context，主要因大型表格和跨端项目对性能敏感，更倾向于通过组件组合或状态管理库（如局部状态 + 自定义 hooks）拆分状态，减少不必要的重渲染。若使用 Context，会通过 “拆分多个 Context”（如将主题和用户信息分为两个 Context）、结合 useMemo 缓存 Context 值等方式优化。

13、详细说明你在 “协议模糊测试系统” 中是如何优化 Webpack 配置的？多线程处理具体用了哪些 loader 或插件？构建速度提升了多少？

优化措施：
简化 loader 设置：仅对必要文件（如 jsx、ts）启用 babel-loader，排除 node_modules 目录；
多线程并行处理：使用 thread-loader 配合 babel-loader，将 JS 编译任务分配到多线程执行，配置如下：

```js
module: {
  rules: [
    {
      test: /\.jsx?$/,
      use: [
        "thread-loader", // 多线程处理
        "babel-loader",
      ],
      exclude: /node_modules/,
    },
  ];
}
```

其他优化：启用 cache-loader 缓存编译结果，分离 runtimeChunk 避免哈希值频繁变化。
效果：构建时间减少约 40%，从原来的 80 秒缩短至 48 秒左右。

14、如何设计前端工程化体系（结合你 “jenkins 配置”“docker 部署” 的经验）？包括代码规范（eslint+pre-commit）、CI/CD 流程、环境隔离等。

结合项目经验，工程化体系包括：
代码规范：
统一开发方式：采用函数组件 + TypeScript，通过 ESLint（配置 eslint-config-react-app）和 Prettier 强制代码风格；
提交规范：使用 husky 的 pre-commit 钩子，通过 lint-staged 对暂存区代码执行 ESLint 检查，不通过则阻止提交。
CI/CD 流程：
用 Jenkins 创建流水线：拉取代码 → 安装依赖 → 执行测试 → 构建打包 → 推送 docker 镜像；
多环境部署：通过 docker 环境变量区分开发 / 测试 / 生产环境，动态注入 API 地址等配置。
环境隔离：开发环境用 webpack-dev-server 本地代理，测试 / 生产环境通过 docker 容器隔离，避免依赖冲突。

15、对模块化方案（ESM、CommonJS）的理解，在 Electron 项目中如何处理主进程与渲染进程的模块依赖？

模块化方案：ESM（ES 模块）是浏览器原生支持的模块化标准，通过 import/export 实现，静态分析；CommonJS 是 Node.js 的模块化方案，通过 require/module.exports 实现，动态加载。
Electron 中主进程与渲染进程的依赖处理：
主进程（Node 环境）使用 CommonJS，渲染进程（浏览器环境）使用 ESM；
共享代码（如工具函数）通过 babel 转换为兼容两种模块的格式，或用 rollup 打包为 UMD 格式；
避免在渲染进程中直接引用 Node 模块，通过 ipc 通信让主进程处理 Node 相关操作（如文件读写），保证渲染进程的浏览器兼容性。

16、你用 Electron 开发桌面端时，如何解决 “electron 代码迁移到网站前端” 的兼容性问题？（结合环境变量、ipc 函数替代方案等细节）

迁移 electron 代码到网站前端时，主要解决以下兼容问题：
环境区分：通过 process.env.NODE_ENV（Electron 中）和 window.\_\_IS_ELECTRON\_\_（网站中）标识环境，条件渲染样式（如 Electron 的窗口边框样式在网站中隐藏）；
ipc 替代：用冗余的 ipc 函数模拟 Electron 的 ipcRenderer，在网站环境中这些函数为空实现或调用 websocket 接口；
路径处理：Electron 的\_\_dirname 在网站中替换为 window.location.pathname，避免文件路径错误；
模块兼容：移除渲染进程中对 fs、path 等 Node 模块的直接引用，改为调用后端 API 获取文件数据。

17、对比 Electron 与其他跨端框架（如 RN、Taro）的技术差异，如果你需要适配鸿蒙系统，会从哪些方面入手？（岗位优先项）

技术差异：
Electron：基于 Chromium+Node.js，用 Web 技术开发桌面端，优势是生态成熟，劣势是包体积大；
RN/Taro：通过 JS 桥接原生组件，适合移动端，性能接近原生，但需维护多端适配逻辑。
鸿蒙适配思路：
先研究鸿蒙 ArkUI 框架的组件模型和状态管理方式，对比 React 的差异；
封装跨端组件库：将常用 UI 组件（如按钮、表格）抽象为适配层，根据环境渲染 ArkUI 或 React 组件；
通信层适配：用鸿蒙的@ohos.net.websocket 替代浏览器 websocket，保证数据交互逻辑一致；
逐步迁移：先适配核心功能（如数据展示），再优化性能和原生特性调用。

18、跨端项目中如何保证三端（iOS/Android/ 鸿蒙）的 UI 一致性和性能？你认为最大的挑战是什么？

UI 一致性：
制定统一设计规范：定义字号、颜色、间距等基础样式变量，通过 CSS 变量或主题文件共享；
使用跨端 UI 库：如 ant-design-mobile 适配多端，或自定义组件库保证渲染一致性。
性能保障：
按需加载：根据端类型（如 iOS/Android）加载对应优化的组件代码；
原生能力调用：复杂场景（如大数据表格）调用端原生 API，避免纯 JS 实现的性能瓶颈。
最大挑战：不同平台的渲染引擎差异（如鸿蒙的方舟引擎与浏览器的 WebKit），可能导致相同 CSS 在不同端表现不一致，需要大量针对性调试。

19、你了解哪些 AI 辅助前端开发的工具或场景？（如代码生成、自动化测试、性能分析）如果要在团队中落地 AI Coding，你会从哪个场景切入？（结合你 “开发效率提升” 的经验）

了解的工具 / 场景：
代码生成：GitHub Copilot 自动生成函数或组件代码；
自动化测试：AI 工具（如 Applitools）通过图像识别检测 UI 回归；
性能分析：基于 AI 的监控工具（如 Lighthouse AI）自动定位性能瓶颈。
落地切入点：结合开发效率提升经验，优先在 “自动化工具生成” 场景落地，例如：
开发 AI 辅助的表单配置工具，通过自然语言描述（如 “生成一个包含姓名、手机号的注册表单”）自动生成 JSON Schema，再通过现有转换工具生成表单项，减少手动编写配置的工作量。

20、你的项目中 “jsonstring-pack 工具” 压缩 JSON 的逻辑是什么？如果用 AI 模型优化压缩算法，你会怎么做？

压缩逻辑：
递归遍历多层嵌套的 JSON，识别重复键名和值（如多个对象都有"status": "pending"）；
建立映射表（如{ "status": 0, "pending": 1 }），用数字替代重复字符串；
去除空格和冗余引号，将 JSON 转换为紧凑格式（如{"a":1}→{a:1}）。
效果：某次测试中 9MB JSON 压缩至 500KB。
AI 优化思路：
训练基于 Transformer 的模型，学习 JSON 结构的规律（如键名的出现频率、嵌套层次特征），动态生成更优的压缩映射表；对非结构化数据（如长文本描述），用 AI 进行语义压缩，进一步减少体积。

21、如何看待 AI 对前端开发的影响？你认为前端工程师需要具备哪些 AI 相关技能？

影响：
效率提升：AI 辅助生成基础代码，减少重复劳动，前端工程师更聚焦逻辑设计和用户体验；
技术门槛变化：简单页面开发可能被自动化工具替代，复杂交互和跨端优化的需求增强。
所需技能：
提示词工程：能清晰描述需求，让 AI 生成更精准的代码；
模型基础认知：了解 AI 工具的局限性（如逻辑错误），能验证和修正生成结果；
跨领域学习：结合 AI 与前端工程化（如自动化测试、性能优化）的融合应用。

22、在 “协议模糊测试系统” 中，你用 protobuf 序列化数据减少 70% 传输量，具体是如何设计数据结构的？遇到过哪些兼容性问题？

数据结构设计：
在协议模糊测试系统中，针对固定结构的 ws 消息（如测试任务状态），定义 protobuf schema：

```js
message TaskStatus {
  required string taskId = 1;
  required int32 progress = 2; // 0-100
  optional string error = 3; // 错误信息，可选
}
```

字段用数字标识（1、2、3）减少传输量，通过 required/optional 控制必要性，实现结构化序列化。
兼容性问题：
新增字段时，老版本解析器可能忽略新增字段，导致数据丢失，解决方案：标记新增字段为 optional；
字段类型变更（如 int32 改为 string）会导致解析错误，通过版本号控制（如在消息头加入 version），不同版本用不同解析逻辑。

23、当你推动 “前端开发规范设计”（引入 TypeScript、eslint）时，如何说服团队接受？（体现沟通与组织能力）

共识建立：先组织团队讨论，结合项目痛点（如类组件维护困难、代码风格混乱），说明引入 TypeScript 和 ESLint 的必要性；
渐进式实施：不强制一次性改造所有代码，先从新功能开始使用函数组件 + TypeScript，再逐步迁移旧代码；
工具支持：编写迁移指南（如类组件转函数组件的步骤），开发自动化脚本（如批量替换 class 为函数组件）；
利益绑定：展示规范带来的实际收益（如测试通过率提升、bug 率下降），让团队感受到价值。

24、你未来想在跨端、AI、工程化哪个方向深入？如何通过技术带动团队成长？（匹配岗位 “技术追求” 要求）

深入方向：优先聚焦跨端开发与工程化，这与美团酒旅业务的多端适配需求高度契合，且能复用我在 Electron 和 Webpack 优化中的经验。
带动团队成长：
技术分享：定期组织跨端适配、工程化工具的实战分享，结合项目案例讲解（如 Electron 代码迁移经验）；
工具沉淀：将配置型表单、JSON 压缩等工具抽象为团队通用库，降低开发门槛；
规范迭代：根据团队反馈优化开发规范，建立 “提出问题 → 讨论方案 → 落地验证” 的良性循环，让技术进步伴随业务成长。
